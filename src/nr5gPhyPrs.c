/*
 * (C) Copyright 2020 Vinsmart - VinGroup.
 *
 * Module: *****
 *
 * Author: THANGTV8
 *
 */

// #include "app_config.h"
#include "nr5gPhyPrs.h"
#include "nr5gPhyConfig.h"

/*!
 * prsSequence2Masks .
 * This lookup table is used by the Prs module to initialize the register of the second sequence without having to shift it 1600 times.
 */
const uint32_t  __attribute__((aligned(ALIGN_8_BYTE))) prsSequence2Masks[NR5G_PHY_PRS_SEQUENCE_2_MASKS_SIZE] =  {
		0x33283032, 0x2abc282a, 0x26762426, 0x20132220, 0x90099110, 0xc804c888, 0x64026444, 0x32013222, 
		0x19009910, 0x0c804c88, 0x06402644, 0x03201322, 0x81900990, 0xc0c804c8, 0x60640264, 0x30320132, 
		0x18190098, 0x0c0c804c, 0x06064026, 0x83032012, 0x41819008, 0xa0c0c804, 0x50606402, 0x28303200, 
		0x94181900, 0xca0c0c80, 0x65060640, 0x32830320, 0x99418190, 0xcca0c0c8, 0x66506064
};

/****************************************private methods*********************************************/
static void nr5gPhyPrsElementProc(
		IN uint32_t cinit,
		IN uint32_t numOutputBits,
		IN EnPrsBitsOrder bitsOrder,
		INOUT uint32_t* sequence1Status,
		INOUT uint32_t* sequence2Status,
		OUT uint8_t* outputP		
);

/****************************************public methods*********************************************/
int nr5gPhyPrsProc(
		IN uint32_t cinit,
		IN uint32_t numOutputBits,
		IN EnPrsBitsOrder bitsOrder,
		OUT uint8_t* outputP
)
{
	uint32_t sequence1Status = 0;
	uint32_t sequence2Status = 0;
	uint32_t oldSequence1Status = 0;
	uint32_t oldSequence2Status = 0;
	uint32_t oldSize = 0;
	uint32_t size = 0;
	uint32_t extraBits = 0;
	uint32_t temp = 0;
	uint32_t i = 0, sequence2 = 0;	
	
	// loop over init sequence. If a bit is set, XOR the mask with existing output
	for (i = 0; i < 31; i++) 
	{
		if (cinit & 1) 
		{
			sequence2 ^= prsSequence2Masks[i];
		}
		cinit >>= 1;
	}

	/* The initial value of the first sequence is always constant therefore the value
	 * of the register after generating and dropping 1600 bits is constant as-well */
	sequence1Status  = NR5G_PHY_PRS_SEQUENCE_1_VALUE;

	/* Save the calculated value of the second register into the object*/
	sequence2Status  = sequence2;

	// Backup the required number of bits,
	oldSize = numOutputBits;

	// Calculate the number of whole bytes,
	size = numOutputBits >> 3;
	if (size) // if more than one byte,
	{
		// Generate that bytes count,
		numOutputBits = size <<3;
		nr5gPhyPrsElementProc(cinit, numOutputBits, bitsOrder, &sequence1Status, &sequence2Status, outputP);
	}

	// Calculate the number of bits remaining,
	extraBits = oldSize&7;
	if (extraBits)	// If there are remaining bits,
	{
		// Backup the old sequences,
		oldSequence1Status = sequence1Status;
		oldSequence2Status = sequence2Status;

		// Backup the first byte of the output (it is going to be overwritten),
		temp = outputP[0];
		numOutputBits = 8;
		nr5gPhyPrsElementProc(cinit, numOutputBits, bitsOrder, &sequence1Status, &sequence2Status, outputP);

		// Restore the original first byte and store the newly generated byte at the end,
		outputP[size] = outputP[0];
		outputP[0] = temp;

		// Extra sequence bits were generated, replace them with the old values,
		sequence1Status >>= (8-extraBits);
		sequence2Status >>= (8-extraBits);

		oldSequence1Status&=0xff000000;
		oldSequence2Status&=0xff000000;
		oldSequence1Status<<=extraBits;
		oldSequence2Status<<=extraBits;
		sequence1Status |= oldSequence1Status;
		sequence2Status |= oldSequence2Status;
	}

	// Return the size to its original value,
	numOutputBits = oldSize;

	return TRUE;
}

void nr5gPhyPrsElementProc(
		IN uint32_t cinit,
		IN uint32_t numOutputBits,
		IN EnPrsBitsOrder bitsOrder,
		INOUT uint32_t* sequence1Status,
		INOUT uint32_t* sequence2Status,
		OUT uint8_t* outputP
)
{
	uint32_t sequence1 = 0, sequence2 = 0 ;
	uint32_t temp1 = 0, temp2 = 0, tempSize = 0, size = 0;
	uint32_t i = 0;

	/* Calculate the number of bytes to be generated*/
	size  = (numOutputBits + 7) >> 3;

	tempSize  = size - 3;

	if(bitsOrder == CN_PRS_BITS_ORDER_REVERSED)
	{
		/* Get the status of both shift registers from passed object to resume the sequence*/
		sequence1 = *sequence1Status;
		sequence2 = *sequence2Status;
	
		/* Reset the index of the for loop*/
		i = 0;
	
		/* Each iteration in the loop generates 24 sequence bits (3 packed output elements)*/
		if( size > 3)
		{
			for( i = 0; i <= tempSize; i += 3)
			{	
				/* Generate 24 sequence bits from sequence 1 and 2*/
				temp1 = ( sequence1 << 3) ^ sequence1 ;
				temp2 = ( sequence2 << 3) ^ sequence2;
				temp2 = ( sequence2 << 2) ^ temp2;
				temp2 = ( sequence2 << 1) ^ temp2;
	
				/* Shift both sequences and feed back the generated bits*/
				sequence1 = ( sequence1 << 24) | ( temp1 >> 7);
				sequence2 = ( sequence2 << 24) | ( temp2 >> 7);
	
				/* Calculate the scrambling sequence*/
				temp1 = temp1 ^ temp2;
	
				outputP[i]     = (uint8_t) (temp1 >> 24) & 0xff;
				outputP[i + 1] = (uint8_t) (temp1 >> 16) & 0xff;
				outputP[i + 2] = (uint8_t) (temp1 >> 8)  & 0xff;
			}
		}
	
		/* generate the remaining bits if the required size was not reached yet*/
		for( ; i < size; i++)
		{			
			/* Generate 8 sequence bits from sequence 1 and 2*/
			temp1 = ( sequence1 << 3) ^ sequence1 ;
			temp2 = ( sequence2 << 3) ^ sequence2;
			temp2 = ( sequence2 << 2) ^ temp2;
			temp2 = ( sequence2 << 1) ^ temp2;
	
			/* Shift both sequences and feed back the generated bits*/
			sequence1 = ( sequence1 << 8) | ( temp1 >> 23);
			sequence2 = ( sequence2 << 8) | ( temp2 >> 23);
	
			/* Store the generated sequence bits into the output buffer*/
			outputP[i] = ( uint8_t)( ( temp1 ^ temp2) >> 24);
		}
	}
	else{
		/* Get the status of both shift registers from passed object to resume the sequence*/
		temp1 = *sequence1Status ;
		temp2 = *sequence2Status ;

		/* Revert the order of the bits of the registers */
		for(i = 0; i < 32 ;i++)
		{
			sequence1 = sequence1 << 1;
			sequence1 |= ((temp1 >> i) & 0x01);
			sequence2 = sequence2 << 1;
			sequence2 |= ((temp2 >> i) & 0x01);
		}

		/* Reset the index of the for loop*/
		i = 0;

		/* Each iteration in the loop generates 24 sequence bits (3 packed output elements)*/
		if( size > 3)
		{			
			for( i = 0; i <= tempSize; i += 3)
			{
				/* Generate 24 sequence bits from sequence 1 and 2*/
				temp1 = ( sequence1 >> 3) ^ sequence1;
				temp2 = ( sequence2 >> 3) ^ sequence2;
				temp2 = ( sequence2 >> 2) ^ temp2;
				temp2 = ( sequence2 >> 1) ^ temp2;

				/* Shift both sequences and feed back the generated bits*/
				sequence1 = ( sequence1 >> 24) | ( temp1 << 7);
				sequence2 = ( sequence2 >> 24) | ( temp2 << 7);

				/* Calculate the scrambling sequence*/
				temp1 = temp1 ^ temp2;

				/* Store the generated sequence bits into the output buffer*/
				outputP[i]  = (uint8_t) (temp1 & 0xff);
				temp1 >>= 8;
				outputP[i+1] = (uint8_t)(temp1 & 0xff);
				temp1 >>= 8;
				outputP[i+2] = (uint8_t)(temp1 & 0xff);
			}
		}

		/* Generate the remaining bits if the required size was not reached yet*/
		for( ; i < size; i++)
		{
			/* Generate 8 sequence bits from sequence 1 and 2*/
			temp1 = ( sequence1 >> 3) ^ sequence1;
			temp2 = ( sequence2 >> 3) ^ sequence2;
			temp2 = ( sequence2 >> 2) ^ temp2;
			temp2 = ( sequence2 >> 1) ^ temp2;

			/* Shift both sequences and feed back the generated bits*/
			sequence1 = ( sequence1 >> 8) | ( temp1 << 23);
			sequence2 = ( sequence2 >> 8) | ( temp2 << 23);

			/* Store the generated sequence bits into the output buffer*/
			outputP[i] = ( uint8_t)( temp1 ^ temp2);
		}

		temp1 = sequence1;
		temp2 = sequence2;

		/* Revert the order of the bits of both registers to be saved into the object */
		for(i = 0; i < 32 ;i++)
		{
			sequence1 = sequence1 << 1;
			sequence1 |= ((temp1 >> i) & 0x01);
			sequence2 = sequence2 << 1;
			sequence2 |= ((temp2 >> i) & 0x01);
		}
	}

	/* Save the current value of both registers into the object*/
	*sequence1Status  = sequence1;
	*sequence2Status  = sequence2;
}
